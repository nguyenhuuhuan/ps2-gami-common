// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	context "context"

	cache "gitlab.id.vin/gami/gami-common/adapters/cache"

	mock "github.com/stretchr/testify/mock"

	redis "github.com/go-redis/redis/v8"

	time "time"
)

// ClusterAdapter is an autogenerated mock type for the ClusterAdapter type
type ClusterAdapter struct {
	mock.Mock
}

// BitCount provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) BitCount(ctx context.Context, key string) (int64, error) {
	ret := _m.Called(ctx, key)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BitCountAll provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) BitCountAll(ctx context.Context, key string) (int64, error) {
	ret := _m.Called(ctx, key)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BitField provides a mock function with given fields: ctx, key, args
func (_m *ClusterAdapter) BitField(ctx context.Context, key string, args []cache.BitFieldModel) ([]int64, error) {
	ret := _m.Called(ctx, key, args)

	var r0 []int64
	if rf, ok := ret.Get(0).(func(context.Context, string, []cache.BitFieldModel) []int64); ok {
		r0 = rf(ctx, key, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int64)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, []cache.BitFieldModel) error); ok {
		r1 = rf(ctx, key, args)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Del provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) Del(ctx context.Context, key string) error {
	ret := _m.Called(ctx, key)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Exists provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) Exists(ctx context.Context, key string) bool {
	ret := _m.Called(ctx, key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Expire provides a mock function with given fields: ctx, key, expiration
func (_m *ClusterAdapter) Expire(ctx context.Context, key string, expiration time.Duration) error {
	ret := _m.Called(ctx, key, expiration)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) error); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Flush provides a mock function with given fields: ctx
func (_m *ClusterAdapter) Flush(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, key, v
func (_m *ClusterAdapter) Get(ctx context.Context, key string, v interface{}) error {
	ret := _m.Called(ctx, key, v)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) error); ok {
		r0 = rf(ctx, key, v)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBit provides a mock function with given fields: ctx, key, offset
func (_m *ClusterAdapter) GetBit(ctx context.Context, key string, offset int64) (int64, error) {
	ret := _m.Called(ctx, key, offset)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) int64); ok {
		r0 = rf(ctx, key, offset)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, int64) error); ok {
		r1 = rf(ctx, key, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBytes provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) GetBytes(ctx context.Context, key string) ([]byte, error) {
	ret := _m.Called(ctx, key)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(context.Context, string) []byte); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInt64 provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) GetInt64(ctx context.Context, key string) (int64, error) {
	ret := _m.Called(ctx, key)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetString provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) GetString(ctx context.Context, key string) (string, error) {
	ret := _m.Called(ctx, key)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HDel provides a mock function with given fields: ctx, key, member
func (_m *ClusterAdapter) HDel(ctx context.Context, key string, member string) error {
	ret := _m.Called(ctx, key, member)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, key, member)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HExists provides a mock function with given fields: ctx, key, field
func (_m *ClusterAdapter) HExists(ctx context.Context, key string, field string) bool {
	ret := _m.Called(ctx, key, field)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, key, field)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// HExistsV2 provides a mock function with given fields: ctx, key, field
func (_m *ClusterAdapter) HExistsV2(ctx context.Context, key string, field string) (bool, error) {
	ret := _m.Called(ctx, key, field)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, key, field)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, key, field)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HGet provides a mock function with given fields: ctx, key, member, v
func (_m *ClusterAdapter) HGet(ctx context.Context, key string, member string, v interface{}) error {
	ret := _m.Called(ctx, key, member, v)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) error); ok {
		r0 = rf(ctx, key, member, v)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HGetAll provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) HGetAll(ctx context.Context, key string) (map[string]string, error) {
	ret := _m.Called(ctx, key)

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func(context.Context, string) map[string]string); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HIncr provides a mock function with given fields: ctx, key, member, quantity
func (_m *ClusterAdapter) HIncr(ctx context.Context, key string, member string, quantity int64) (int64, error) {
	ret := _m.Called(ctx, key, member, quantity)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) int64); ok {
		r0 = rf(ctx, key, member, quantity)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, int64) error); ok {
		r1 = rf(ctx, key, member, quantity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HIncrBy provides a mock function with given fields: ctx, key, field, incr
func (_m *ClusterAdapter) HIncrBy(ctx context.Context, key string, field string, incr int64) error {
	ret := _m.Called(ctx, key, field, incr)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) error); ok {
		r0 = rf(ctx, key, field, incr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HMGet provides a mock function with given fields: ctx, key, field
func (_m *ClusterAdapter) HMGet(ctx context.Context, key string, field []string) ([]interface{}, error) {
	ret := _m.Called(ctx, key, field)

	var r0 []interface{}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) []interface{}); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, key, field)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HMSet provides a mock function with given fields: ctx, key, fields
func (_m *ClusterAdapter) HMSet(ctx context.Context, key string, fields interface{}) error {
	ret := _m.Called(ctx, key, fields)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) error); ok {
		r0 = rf(ctx, key, fields)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HSet provides a mock function with given fields: ctx, key, field, value
func (_m *ClusterAdapter) HSet(ctx context.Context, key string, field string, value interface{}) error {
	ret := _m.Called(ctx, key, field, value)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) error); ok {
		r0 = rf(ctx, key, field, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Incr provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) Incr(ctx context.Context, key string) (int64, error) {
	ret := _m.Called(ctx, key)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IncrBy provides a mock function with given fields: ctx, key, quantity
func (_m *ClusterAdapter) IncrBy(ctx context.Context, key string, quantity int64) (int64, error) {
	ret := _m.Called(ctx, key, quantity)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) int64); ok {
		r0 = rf(ctx, key, quantity)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, int64) error); ok {
		r1 = rf(ctx, key, quantity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Keys provides a mock function with given fields: ctx, pattern
func (_m *ClusterAdapter) Keys(ctx context.Context, pattern string) ([]string, error) {
	ret := _m.Called(ctx, pattern)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, pattern)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LLength provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) LLength(ctx context.Context, key string) (int64, error) {
	ret := _m.Called(ctx, key)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LPush provides a mock function with given fields: ctx, key, val
func (_m *ClusterAdapter) LPush(ctx context.Context, key string, val ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, val...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) error); ok {
		r0 = rf(ctx, key, val...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LRange provides a mock function with given fields: ctx, key, start, stop
func (_m *ClusterAdapter) LRange(ctx context.Context, key string, start int64, stop int64) ([]string, error) {
	ret := _m.Called(ctx, key, start, stop)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) []string); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, int64, int64) error); ok {
		r1 = rf(ctx, key, start, stop)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PFAdd provides a mock function with given fields: ctx, key, list
func (_m *ClusterAdapter) PFAdd(ctx context.Context, key string, list []string) error {
	ret := _m.Called(ctx, key, list)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) error); ok {
		r0 = rf(ctx, key, list)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PFCount provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) PFCount(ctx context.Context, key string) int64 {
	ret := _m.Called(ctx, key)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// RAppendIntArray provides a mock function with given fields: ctx, key, value
func (_m *ClusterAdapter) RAppendIntArray(ctx context.Context, key string, value []int64) (bool, error) {
	ret := _m.Called(ctx, key, value)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string, []int64) bool); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, []int64) error); ok {
		r1 = rf(ctx, key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBitCount provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) RBitCount(ctx context.Context, key string) (int64, error) {
	ret := _m.Called(ctx, key)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RGetBit provides a mock function with given fields: ctx, key, offset
func (_m *ClusterAdapter) RGetBit(ctx context.Context, key string, offset int64) (int64, error) {
	ret := _m.Called(ctx, key, offset)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) int64); ok {
		r0 = rf(ctx, key, offset)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, int64) error); ok {
		r1 = rf(ctx, key, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RGetIntArray provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) RGetIntArray(ctx context.Context, key string) ([]int64, error) {
	ret := _m.Called(ctx, key)

	var r0 []int64
	if rf, ok := ret.Get(0).(func(context.Context, string) []int64); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int64)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ROptimize provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) ROptimize(ctx context.Context, key string) (bool, error) {
	ret := _m.Called(ctx, key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPop provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) RPop(ctx context.Context, key string) error {
	ret := _m.Called(ctx, key)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RPush provides a mock function with given fields: ctx, key, val
func (_m *ClusterAdapter) RPush(ctx context.Context, key string, val ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, val...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) error); ok {
		r0 = rf(ctx, key, val...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RSetBit provides a mock function with given fields: ctx, key, offset, value
func (_m *ClusterAdapter) RSetBit(ctx context.Context, key string, offset int64, value int) (int64, error) {
	ret := _m.Called(ctx, key, offset, value)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int) int64); ok {
		r0 = rf(ctx, key, offset, value)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, int64, int) error); ok {
		r1 = rf(ctx, key, offset, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RSetIntArray provides a mock function with given fields: ctx, key, value
func (_m *ClusterAdapter) RSetIntArray(ctx context.Context, key string, value []int64) (bool, error) {
	ret := _m.Called(ctx, key, value)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string, []int64) bool); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, []int64) error); ok {
		r1 = rf(ctx, key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SAdd provides a mock function with given fields: ctx, key, list
func (_m *ClusterAdapter) SAdd(ctx context.Context, key string, list []string) error {
	ret := _m.Called(ctx, key, list)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) error); ok {
		r0 = rf(ctx, key, list)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SCard provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) SCard(ctx context.Context, key string) int64 {
	ret := _m.Called(ctx, key)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// SMem provides a mock function with given fields: ctx, key, value
func (_m *ClusterAdapter) SMem(ctx context.Context, key string, value string) bool {
	ret := _m.Called(ctx, key, value)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// SRem provides a mock function with given fields: ctx, key, list
func (_m *ClusterAdapter) SRem(ctx context.Context, key string, list []string) error {
	ret := _m.Called(ctx, key, list)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) error); ok {
		r0 = rf(ctx, key, list)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Set provides a mock function with given fields: ctx, key, v, expiration
func (_m *ClusterAdapter) Set(ctx context.Context, key string, v interface{}, expiration time.Duration) error {
	ret := _m.Called(ctx, key, v, expiration)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) error); ok {
		r0 = rf(ctx, key, v, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetBit provides a mock function with given fields: ctx, key, offset, value
func (_m *ClusterAdapter) SetBit(ctx context.Context, key string, offset int64, value int) error {
	ret := _m.Called(ctx, key, offset, value)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int) error); ok {
		r0 = rf(ctx, key, offset, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetString provides a mock function with given fields: ctx, key, v, expiration
func (_m *ClusterAdapter) SetString(ctx context.Context, key string, v interface{}, expiration time.Duration) error {
	ret := _m.Called(ctx, key, v, expiration)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) error); ok {
		r0 = rf(ctx, key, v, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ZAdd provides a mock function with given fields: ctx, key, v
func (_m *ClusterAdapter) ZAdd(ctx context.Context, key string, v *redis.Z) error {
	ret := _m.Called(ctx, key, v)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Z) error); ok {
		r0 = rf(ctx, key, v)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ZAdds provides a mock function with given fields: ctx, key, v
func (_m *ClusterAdapter) ZAdds(ctx context.Context, key string, v ...*redis.Z) error {
	_va := make([]interface{}, len(v))
	for _i := range v {
		_va[_i] = v[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.Z) error); ok {
		r0 = rf(ctx, key, v...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ZCard provides a mock function with given fields: ctx, key
func (_m *ClusterAdapter) ZCard(ctx context.Context, key string) (int64, error) {
	ret := _m.Called(ctx, key)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZIncr provides a mock function with given fields: ctx, key, member
func (_m *ClusterAdapter) ZIncr(ctx context.Context, key string, member *redis.Z) error {
	ret := _m.Called(ctx, key, member)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Z) error); ok {
		r0 = rf(ctx, key, member)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ZRank provides a mock function with given fields: ctx, key, member
func (_m *ClusterAdapter) ZRank(ctx context.Context, key string, member string) (int64, error) {
	ret := _m.Called(ctx, key, member)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string, string) int64); ok {
		r0 = rf(ctx, key, member)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, key, member)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZRevRange provides a mock function with given fields: ctx, key, max
func (_m *ClusterAdapter) ZRevRange(ctx context.Context, key string, max int64) ([]redis.Z, error) {
	ret := _m.Called(ctx, key, max)

	var r0 []redis.Z
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) []redis.Z); ok {
		r0 = rf(ctx, key, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.Z)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, int64) error); ok {
		r1 = rf(ctx, key, max)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZRevRank provides a mock function with given fields: ctx, key, member
func (_m *ClusterAdapter) ZRevRank(ctx context.Context, key string, member string) (int64, error) {
	ret := _m.Called(ctx, key, member)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string, string) int64); ok {
		r0 = rf(ctx, key, member)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, key, member)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZScore provides a mock function with given fields: ctx, key, member
func (_m *ClusterAdapter) ZScore(ctx context.Context, key string, member string) (float64, error) {
	ret := _m.Called(ctx, key, member)

	var r0 float64
	if rf, ok := ret.Get(0).(func(context.Context, string, string) float64); ok {
		r0 = rf(ctx, key, member)
	} else {
		r0 = ret.Get(0).(float64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, key, member)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewClusterAdapter interface {
	mock.TestingT
	Cleanup(func())
}

// NewClusterAdapter creates a new instance of ClusterAdapter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewClusterAdapter(t mockConstructorTestingTNewClusterAdapter) *ClusterAdapter {
	mock := &ClusterAdapter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
